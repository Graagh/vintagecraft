package at.tyron.vintagecraft.WorldGen.GenLayers.River;

import at.tyron.vintagecraft.World.BiomeVC;
import at.tyron.vintagecraft.WorldGen.GenLayers.GenLayerVC;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;

public class GenLayerRiverMix extends GenLayerVC {

	private GenLayer biomePatternGeneratorChain;
	private GenLayer riverPatternGeneratorChain;
	int[] layerBiomes;
	int[] layerRivers;
	int[] layerOut;
	int xnext = 0;
	int xprev = 0;
	int znext = 0;
	int zprev = 0;

	public GenLayerRiverMix(long par1, GenLayer par3GenLayer, GenLayer par4GenLayer)
	{
		super(par1);
		this.biomePatternGeneratorChain = par3GenLayer;
		this.riverPatternGeneratorChain = par4GenLayer;
	}

	/**
	 * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
	 * amounts, or biomeList[] indices based on the particular GenLayer subclass.
	 */
	@Override
	public int[] getInts(int x, int z, int xSize, int zSize) {
		//layerBiomes = this.biomePatternGeneratorChain.getInts(x-1, z-1, xSize+2, zSize+2);
		layerBiomes = this.biomePatternGeneratorChain.getInts(x, z, xSize, zSize);
		layerRivers = this.riverPatternGeneratorChain.getInts(x, z, xSize, zSize);
		layerOut = IntCache.getIntCache(xSize * zSize);

		for (int zElement = 0; zElement < zSize; ++zElement) {
			for (int xElement = 0; xElement < xSize; ++xElement) {
				int index = xElement + zElement * xSize;
				
				int biomeid = layerBiomes[index];
				int isriver = layerRivers[index];

				xnext = index-1;
				xprev = index+1;
				znext = index-zSize;
				zprev = index+zSize;

				// No river in ocean and mountain biomes
				if (BiomeVC.isOceanic(biomeid) || BiomeVC.isMountainous(biomeid)) {
					layerOut[index] = biomeid;
				} else if (isriver > 0) {
					layerOut[index] = isriver;

					//Here we make sure that rivers dont run along ocean/beach splits. We turn the river into oceans.
					if (BiomeVC.isShore(biomeid)) {
						
						layerOut[index] = BiomeVC.ocean.biomeID;
						
						if (xnext < 0 || xprev >= layerBiomes.length || znext < 0 || zprev >= layerBiomes.length) continue;
						
						if(inBounds(xnext, layerOut) && layerOut[xnext] == BiomeVC.river.biomeID) {
							layerOut[xnext] = BiomeVC.ocean.biomeID;
						}
						if(inBounds(znext, layerOut) && layerOut[znext] == BiomeVC.river.biomeID) {
							layerOut[znext] = BiomeVC.ocean.biomeID;
						}
						
						if(inBounds(zprev, layerOut) && BiomeVC.isOceanic(layerBiomes[zprev]) && layerRivers[zprev] == 0) {
							layerOut[index] = biomeid;
						}
						if(inBounds(znext, layerOut) && BiomeVC.isOceanic(layerBiomes[znext]) && layerRivers[znext] == 0) {
							layerOut[index] = biomeid;
						}
						if(inBounds(xnext, layerOut) && BiomeVC.isOceanic(layerBiomes[xnext]) && layerRivers[xnext] == 0) {
							layerOut[index] = biomeid;
						}
						if(inBounds(xprev, layerOut) && BiomeVC.isOceanic(layerBiomes[xprev]) && layerRivers[xprev] == 0) {
							layerOut[index] = biomeid;
						}
					}
				}
				else {
					layerOut[index] = biomeid;
				}

				//Similar to above, if we're near a lake, we turn the river into lake.
				removeRiver(index, BiomeVC.lake.biomeID);
				removeRiver(index, BiomeVC.MountainsEdge.biomeID);

				validateInt(layerOut, index);
			}
		}
		return layerOut;
	}

	public void removeRiver(int index, int biomeToReplaceWith)
	{		
		if(layerOut[index] == BiomeVC.river.biomeID)
		{
			if(xnext >= 0 && layerBiomes[xnext] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(znext >= 0 && layerBiomes[znext] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(xprev < layerBiomes.length && layerBiomes[xprev] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
			if(zprev < layerBiomes.length && layerBiomes[zprev] == biomeToReplaceWith)
			{
				layerOut[index] = biomeToReplaceWith;
			}
		}
	}

	public boolean inBounds(int index, int[] array)
	{
		if(index < array.length && index >= 0)
			return true;
		return false;
	}

	/**
	 * Initialize layer's local worldGenSeed based on its own baseSeed and the world's global seed (passed in as an
	 * argument).
	 */
	@Override
	public void initWorldGenSeed(long par1)
	{
		this.biomePatternGeneratorChain.initWorldGenSeed(par1);
		this.riverPatternGeneratorChain.initWorldGenSeed(par1);
		super.initWorldGenSeed(par1);
	}

}
