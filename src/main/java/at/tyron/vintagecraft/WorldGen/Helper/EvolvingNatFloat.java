package at.tyron.vintagecraft.WorldGen.Helper;

import at.tyron.vintagecraft.WorldGen.Helper.NatFloat.Distribution;
import at.tyron.vintagecraft.WorldProperties.EnumTransformFunction;
import net.minecraft.util.MathHelper;

public class EvolvingNatFloat {
	EnumTransformFunction function;
	float factor;
	
	float maxvalue;
	boolean maxlimit = false;
	
	float firstvalue;
	float offset;
	
	NatFloat firstval;
	
	public EvolvingNatFloat(float averagevalue, float variance, Distribution distribution, EnumTransformFunction function, float factor) {
		this.function = function;
		this.factor = factor;
		
		firstval = NatFloat.create(distribution, averagevalue, variance);
	}
	
	public void init() {
		firstvalue = firstval.nextFloat();
	}
	
	
	public static EvolvingNatFloat createIdentical(float value) {
		return new EvolvingNatFloat(value, 0f, Distribution.UNIFORM, EnumTransformFunction.IDENTICAL, 0f);	
	}
	
	public static EvolvingNatFloat createUniform(float averagevalue, float variance, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.UNIFORM, function, factor);
	}
	
	public static EvolvingNatFloat createGauss(float averagevalue, float variance, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.GAUSSIAN, function, factor);
	}

	public static EvolvingNatFloat createInvGauss(float averagevalue, float variance, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.INVERSEGAUSSIAN, function, factor);
	}

	public static EvolvingNatFloat createTri(float averagevalue, float variance, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.TRIANGLE, function, factor);
	}
	
	public static EvolvingNatFloat createDirac(float averagevalue, float variance, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.DIRAC, function, factor);
	}

	public static EvolvingNatFloat create(float averagevalue, float variance, Distribution distribution, EnumTransformFunction function, float factor) {
		return new EvolvingNatFloat(averagevalue, variance, distribution, function, factor);
	}

	
	public void setFirstValue(float value) {
		firstvalue = value;
	}
	
	public EvolvingNatFloat setOffset(float offset) {
		this.offset = offset;
		return this;
	}
	

	public EvolvingNatFloat copyWithOffset(float offset) {
		return create(firstval.averagevalue, firstval.variance, firstval.distribution, function, factor).setOffset(this.offset + offset);
	}
	
	/*
	
	public static EvolvingNatFloat createUniform(float averagevalue, float variance) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.UNIFORM, Function.IDENTICAL, 0f);
	}
	
	public static EvolvingNatFloat createGauss(float averagevalue, float variance) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.GAUSSIAN, Function.IDENTICAL, 0f);
	}

	public static EvolvingNatFloat createInvGauss(float averagevalue, float variance) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.INVERSEGAUSSIAN, Function.IDENTICAL, 0f);
	}

	public static EvolvingNatFloat createTri(float averagevalue, float variance) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.TRIANGLE, Function.IDENTICAL, 0f);
	}
	
	public static EvolvingNatFloat createDirac(float averagevalue, float variance) {
		return new EvolvingNatFloat(averagevalue, variance, Distribution.DIRAC, Function.IDENTICAL, 0f);
	}
	*/
	
	
	EvolvingNatFloat setMax(float value) {
		this.maxvalue = value;
		maxlimit = true;
		return this;
	}

	
	
	// Sequence generated by DynTreeGen will always run from 0 to 1000
	public float nextFloat(float sequence) {
		return nextFloat(1f, sequence);
	}
	
	
	public float nextFloat(float multiplier, float sequence) {
		float result = firstvalue;
		
		switch (function) {
			case IDENTICAL: break;
			case LINEAR: result = firstvalue + factor * sequence; break;
			
			case LINEARREDUCE: result = firstvalue - firstvalue/Math.abs(firstvalue) * factor * sequence; break;
			case LINEARINCREASE: result = firstvalue + firstvalue/Math.abs(firstvalue) * factor * sequence; break;
			
			case INVERSELINEAR: result = firstvalue - factor * sequence; break;
			case QUADRATIC: result = firstvalue + (factor * sequence) * (factor * sequence); break;
			case INVERSEQUADRATIC: result = firstvalue + 1f/(factor * (sequence+1)); break;
			case SINUS: result = firstvalue * MathHelper.sin(factor * sequence); break;
			case COSINUS: result = firstvalue * MathHelper.cos(factor * sequence); break;
			case WOBBLE: result = firstvalue + MathHelper.sin(factor * sequence); break;
		}
		
		if (maxlimit) return Math.min(maxvalue, offset + result);
		
		return offset + result;
	}



}
